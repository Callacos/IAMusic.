import sqlite3
import os
from db_utilis import get_db_connection
from text_analyzer import extract_keywords_with_ollama

def get_db_connection():
    db_path = "/home/callacos/IAMusic./app/database/music.db"
    return sqlite3.connect(db_path)

def get_playlist_from_phrase(user_id, phrase):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Extraire les mots de la phrase
        mots = phrase.lower().split()
        format_mots = ",".join("?" for _ in mots)
        cursor.execute(f"SELECT id_mot_cle FROM mot_cle WHERE mot IN ({format_mots})", mots)
        mots_ids = [row[0] for row in cursor.fetchall()]
        if not mots_ids:
            print("Aucun mot-cl√© trouv√©.")
            return ["spotify:playlist:37i9dQZF1DWVuV87wUBNwc"]

        # R√©cup√©rer les genres aim√©s par l'utilisateur
        cursor.execute("""
            SELECT gg.id_genre
            FROM gout_utilisateur gu
            JOIN gout_genre gg ON gu.id_gout = gg.id_gout
            WHERE gu.id_utilisateur = ?
        """, (user_id,))
        genres_ids = [row[0] for row in cursor.fetchall()]
        if not genres_ids:
            print("L'utilisateur n'a aucun go√ªt enregistr√©.")
            return ["spotify:playlist:37i9dQZF1DWVuV87wUBNwc"]

        # Requ√™te finale
        format_mots = ",".join("?" for _ in mots_ids)
        format_genres = ",".join("?" for _ in genres_ids)
        query = f"""
            SELECT p.uri
            FROM playlist p
            JOIN association a ON p.id_association = a.id_association
            WHERE a.id_mot_cle IN ({format_mots})
            AND a.id_genre IN ({format_genres})
            ORDER BY RANDOM()
            LIMIT 1
        """
        print("üîç Requ√™te avec id_mot_cle :", mots_ids)
        print("üîç Requ√™te avec id_genre :", genres_ids)

        cursor.execute(query, (*mots_ids, *genres_ids))
        result = cursor.fetchone()

        if result:
            print("üé∂ Playlist recommand√©e :", result[0])
            return [result[0]]
        else:
            print("üò¢ Aucune playlist trouv√©e.")
            return ["spotify:playlist:5gcRNWl6qZOW5Zevr9y2e6"]

    except sqlite3.Error as e:
        print(f"‚ùå Erreur SQLite : {e}")
        return ["spotify:playlist:5gcRNWl6qZOW5Zevr9y2e6"]

    finally:
        if conn:
            conn.close()

def get_enhanced_playlist_from_phrase(user_id, phrase):
    # R√©cup√©rer les recommandations de base
    base_recommendations = get_playlist_from_phrase(user_id, phrase)
    
    # Analyser l'historique pour affiner les recommandations
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        # R√©cup√©rer les playlists les plus √©cout√©es
        cursor.execute("""
            SELECT playlist_uri, COUNT(*) as count 
            FROM historique_ecoute 
            WHERE id_utilisateur = ? 
            GROUP BY playlist_uri 
            ORDER BY count DESC 
            LIMIT 5
        """, (user_id,))
        favorite_playlists = cursor.fetchall()
        
        # Analyser les interactions positives
        cursor.execute("""
            SELECT playlist_uri, COUNT(*) as interactions
            FROM interactions
            WHERE id_utilisateur = ? AND type_interaction != 'skip'
            GROUP BY playlist_uri
            ORDER BY interactions DESC
            LIMIT 5
        """, (user_id,))
        positive_interactions = cursor.fetchall()
        
        # Si aucune recommandation de base, utiliser les favorites directement
        if not base_recommendations and (favorite_playlists or positive_interactions):
            # Combiner les playlists favorites et interactions positives
            combined_playlists = {}
            
            # Ajouter poids des playlists √©cout√©es
            for uri, count in favorite_playlists:
                combined_playlists[uri] = count
            
            # Ajouter poids des interactions positives (avec plus de valeur)
            for uri, count in positive_interactions:
                if uri in combined_playlists:
                    combined_playlists[uri] += count * 1.5  # Bonus pour interactions positives
                else:
                    combined_playlists[uri] = count * 1.5
            
            # Trier par score et prendre les 3 meilleures
            sorted_playlists = sorted(combined_playlists.items(), key=lambda x: x[1], reverse=True)
            return [uri for uri, _ in sorted_playlists[:3]]
        
        # Si des recommandations existent, prioritiser celles que l'utilisateur aime
        elif base_recommendations:
            # Cr√©er un dictionnaire des URIs recommand√©es avec un score initial
            enhanced_recommendations = {uri: 1 for uri in base_recommendations}
            
            # Augmenter le score des playlists √©cout√©es pr√©c√©demment
            for uri, count in favorite_playlists:
                if uri in enhanced_recommendations:
                    enhanced_recommendations[uri] += count * 0.5
            
            # Augmenter davantage le score pour les interactions positives
            for uri, count in positive_interactions:
                if uri in enhanced_recommendations:
                    enhanced_recommendations[uri] += count * 1.0
            
            # Trier les recommandations par score et conserver l'ordre
            sorted_recommendations = sorted(
                enhanced_recommendations.items(), 
                key=lambda x: x[1], 
                reverse=True
            )
            
            # Retourner les URIs ordonn√©es
            return [uri for uri, _ in sorted_recommendations]
        
    except Exception as e:
        print(f"‚ùå Erreur lors de l'am√©lioration des recommandations: {e}")
    finally:
        conn.close()
    
    # En cas d'erreur ou si aucune am√©lioration n'est possible, retourner les recommandations originales
    return base_recommendations















# Route qui re√ßoit la phrase du front-end
@app.route('/phrase', methods=['POST'])
def recevoir_phrase():
    data = request.get_json()
    phrase = data.get('phrase')

    # V√©rifier que l'utilisateur est connect√©
    if 'user_id' not in session:
        return "‚ùå Utilisateur non connect√©"

    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        # R√©cup√©rer l'ID de l'utilisateur
        cursor.execute("SELECT id_utilisateur FROM utilisateur WHERE nom = ?", (session["user_id"],))
        utilisateur = cursor.fetchone()
        
        if utilisateur:
            user_id = utilisateur[0]
            
            # Enregistrer la phrase dans l'historique de recherche
            try:
                cursor.execute(
                    "INSERT INTO historique_recherche (id_utilisateur, phrase) VALUES (?, ?)",
                    (user_id, phrase)
                )
                conn.commit()
                print(f"‚úÖ Phrase '{phrase}' enregistr√©e dans l'historique pour l'utilisateur {user_id}")
            except Exception as e:
                print(f"‚ùå Erreur lors de l'enregistrement dans l'historique: {e}")
            
            # Obtenir les recommandations am√©lior√©es
            uris = get_enhanced_playlist_from_phrase(user_id, phrase)
        else:
            conn.close()
            return "‚ùå Utilisateur non trouv√©"
    finally:
        conn.close()

    if uris:
        # Enregistrer √©galement dans l'historique d'√©coute lorsqu'une playlist est jou√©e
        try:
            jouer_playlist(uris[0])  # Lecture automatique si URI trouv√©e
            # Note: l'enregistrement dans historique_ecoute devrait √™tre fait dans jouer_playlist()
            
            url = f"https://open.spotify.com/playlist/{uris[0].split(':')[-1]}"
            return f"<p>Playlist trouv√©e :</p><a href='{url}' target='_blank'>{url}</a>"
        except Exception as e:
            print(f"‚ùå Erreur lors de la lecture de la playlist: {e}")
            return f"<p>Erreur lors de la lecture: {str(e)}</p>"
    else:
        return "<p>Aucune playlist trouv√©e pour cette phrase.</p>"
    


    # √âtape 2 : normalisation
    synonym_map = {
        "bouger": "bouge",
        "boug√©": "bouge",
        "je veux bouge": "bouge",
        "danser": "bouge",
        "dance": "bouge",
        "rhythmic": "bouge",
        "calm": "relax",
        "chill": "relax",
        "peace": "relax",
        "relaxing": "relax",
        "tense": "stress",
        "anxious": "stress",
        "energetic": "√©nergie",
        "motivation": "√©nergie",
        "stress√©": "stress",
        "cri√©": "Crier",
        "scream": "Crier",

    }

    normalized_keywords = [synonym_map.get(k, k) for k in keywords]
    keywords = normalized_keywords